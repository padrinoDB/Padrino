[["index.html", "1 About", " 1 About Welcome to the PADRINO IPM Database project. We are in the process of digitizing as many Integral Projection Models (IPMs) as possible. The ultimate goal is to provide an interface to reconstruct these models for synthesis with a user-friendly interface. Right now, the only engine available for this is written in R, though a long term goal is to provide bindings to other languages (a technical document describing how to write those is on the to-do list). PADRINO stores IPMs as a text strings that represent the form for the sub-kernels, vital rate models, and any other expressions needed to generate an IPM iteration. It stores parameter values in a separate table, and substitutes those in for the symbols in the text strings when a user requests a built model. The result is a set of sub-kernels, trait distributions, and, optionally, other user-requested information, such as vital rate functions. Table 1.1: Total number of ipm_ids, species, and publications contained in PADRINO. All of these models are quality checked, and will reproduce the published IPM behavior. Kingdom IPMs Species Publications Animalia 22 16 14 Plantae 258 40 26 "],["digitization-guide.html", "2 Digitization Guide 2.1 Required tools 2.2 Steps to digitizing 2.3 Begin digitizing the model 2.4 Test the model 2.5 The tables 2.6 Common issues", " 2 Digitization Guide Welcome to the project! PADRINO is an open access database that aims to store text representations of Integral Projection Models (IPMs). An important goal is to ensure these models can be rebuilt as published, though there are exceptions in some cases (see here). Beyond the functional forms and parameters, we also store metadata to help users select models for synthesis. It is important to note that PADRINO does not store raw data (e.g. individual level data collected from field studies). Other projects have already set out to accomplish this goal (e.g. BIEN, popler, BioTime), and we do not believe in duplicating those efforts specifically for IPMs. However, there is still a gap to fill in terms of generating sets of kernels, population states, and life history traits from published models for pressing synthetic questions in ecology. Throughout the course of this guide and the Writing PADRINO Expressions Guide, references to ipmr will pop up. ipmr is the R package that powers the re-implementation of PADRINO models in R. There is an introduction to ipmr here.1 2.1 Required tools For digitizers, this project makes heavy use of GitHub, RStudio, Google Sheets, and Slack. If you do not already have a GitHub account, you can make one here and walk through the steps of linking GitHub and RStudio here. For the most part, you will only need to know how to clone a repository, and then how to keep your local version in sync with the online version (via pulling, pushing, and branching). Please let me know if youd like a more thorough introduction to this during on boarding and Ill make sure to go through the linking/syncing steps with you! A technical setup guide is availabe here. 2.1.1 Initial setup Once youve set up GitHub and RStudio to talk to each other, it will be useful to create a local copy of the Padrino repository on your computer. This will give you access to, among other things, local copies of this guide and the others, as well as a the Email an Author template. To do this: Open Rstudio In the top right corner, there will be a Project: (None) tab. Click this dropdown, and select New Project. Select Version Control from the first menu. Select Git from the second menu. Enter https://github.com/padrinoDB/Padrino into the Repository URL bar. Select a directory to place your version in using the Create project as subdirectory of:. Click Create button. Once all files are downloaded and the new R session is started, click on the Git tab. This will usually be in the same Pane as the Environment and History tabs in RStudio. Once in that tab, click New Branch and give your branch an easily recognizable name (e.g. sam_branch). The name should not have any spaces or apostrophes. You can now safely edit documents and add notes as you like without affecting the main branch! 2.2 Steps to digitizing There a few steps in digitizing an IPM in PADRINO. These are outlined briefly here, and each has a deeper dive (when applicable) somewhere below (with links to each). 2.2.1 Identify whether a publication contains an IPM The first step of entering a paper is to find papers and store them in a place that the PADRINO team can find later. Below, we go through the steps this involves, in order. Tracking our incoming literature channel on Slack, as well as checking other sources for papers we may have missed (e.g. Google Scholar, Web of Science, Twitter (seriously, its a good source)).2 If a paper has an IPM, then we first add it to our shared GoogleSheet containing citation information, species names, author contact info, and digitization progress. This can be accessed here. Please email me at levisc8@gmail.com to get access. Download a PDF of the paper into the shared Dropbox literature folder. Additionally, if the publication contains an Appendix with further information, store that as well. The folders relative path within the PADRINO dropbox folder is: Dropbox/PADRINO/Literature/PDF/KINGDOM-NAME. If you are ready to begin digitizing the paper, then update the Digitized and Digitizer columns in the Google Sheet to reflect that you are working on this paper. 2.2.2 Determine the number of ipm_ids in the paper The ipm_id currently takes the place of an SQL key. ipm_id is the only column that appears in every table in PADRINO. Some models may contain many rows in some tables while others contain none. PADRINO needs some piece of information to make sure we do not accidentally pull in information from a different model at build time. The ipm_id column fills this role. Because of the way that ipmr handles models with some grouping effects (e.g. plots, years, populations), it may be possible to re-construct many kernels using a slightly modified functional form (i.e. appending a suffix corresponding to the group effects). Grouping models saves us a lot of typing/copy+pasting (which can be error prone). The rules for when models can be grouped with the same ipm_id are as follows: If there are multiple sites and their GPS coordinates are given such that they are clearly in different geographic locations, then each set of unique coordinates gets its own ipm_id. Within a set of unique coordinates, the following rules may be applied to either further group or split models into additional ipm_ids. If there are many versions of the same sub-kernel, and all of these have the same functional form and differ only in their parameter values, we can use a single ipm_id. The above situation is commonly the result of mixed effects models, or models where something like an experimental treatment is a fixed effect. More generally, if an underlying regression model contains some mixture of discrete and continuous predictors, then the result is going to be multiple kernels - 1 for each level of the discrete predictor. For example, a growth model fit to data from many transitions may use year as fixed or random effect. In this case, the functional form of the growth model is the same for all years, but the parameter values differ, generating a unique kernel for each year. We can use the same functional form to generate these unique kernels, so we can use a single ipm_id for this IPM. If any of the underlying kernels have different functional forms across a discrete grouping variable, then we cannot combine them, and they must be split into separate ipm_ids. Unique functional forms in the same sub-kernel may happen when, for example, different sites or years generate such different demographic responses that the authors could not find a way to keep everything in one model. Generally, if the authors report using different regression models, or different kernels, for the same vital rate, then we will need to split up the model into different ipm_ids.3 Once we have decided how many entries the paper is going to get, then we can begin entering the model. Since there may be multiple people working on PADRINO in parallel, we will discuss a system to keep your ipm_ids unique from others during your first training session. 2.3 Begin digitizing the model Details on each column and each table are provided below. Some details on functional form syntax are given below, but a much longer introduction is available here, and an introduction to ipmr (which powers all of PADRINO) is available here. 2.4 Test the model Testing the model requires testing the output against some expected target value. To do this, youll need to install the pdbDigitUtils package with the following snippet: if(!requireNamespace(&quot;remotes&quot;)) { install.packages(&quot;remotes&quot;) } remotes::install_github(&quot;padrinoDB/pdbDigitUtils&quot;) This package contains a couple helpful functions for loading a locally stored development version of the database, and testing outputs from individual models. read_pdb loads the Excel version of the database into R, and test_model lets you test a newly entered model. The package is still under development, so additional functionality can be added as requested. Please use the Issues Tab on the Github repository to create function requests and report bugs. If the newly entered model passes all tests, then it is ready to enter the production version of the database. At this point, I am still working out who should have access to that, so for now, just send me your version of the database via email (levisc8@gmail.com). For more on testing, see the TestTargets table overview below. 2.5 The tables Next, we will walk through individual tables and the columns within them. The first is Metadata. 2.5.1 Metadata The metadata table contains information on species taxonomy, publication information, study duration, ecoregion, and any treatments applied to the study population. The columns are: ipm_id: This is a unique identifier for each model. It is 6 alphanumeric characters with no spaces. 2.5.1.1 Taxonomic information species_author: This the Latin species name as used by the author in the manuscript. Note that this name may no longer be the accepted name. This has the format genus_species (e.g. Ligustrum_obtusifolium, Ovis_aries). Some authors may include additional information (subspecies, varieties, etc). These can be appended using underscores (e.g. genus_species_subspp_var). NB: If you are already familiar with COMPADRE, we DO NOT use the the extra _# to distinguish between models/publications. For example, two publications in COMPADRE on Lonicera_maackii would be entereed as Lonicera_maackii and Lonicera_maackii_2. We just use different ipm_ids and apa_citations to distinguish these models. species_accepted: The accepted name of the species (currently from Global Names Resolver and Catalog of Life, but may switch to the Leipzig List for Plantae soon). This follows the format genus_species_subspecies. You can use the experimental resolve_pdb_tax function in pdbDigitUtils for this, though it may not work perfectly, and results should be checked. The following taxonomic categories contain the \"tax_\" prefix to prevent naming collisions with some R functions. tax_genus: The accepted genus. tax_family: The accepted family. tax_order: The accepted order. tax_class: The accepted class. tax_phylum: The accepted phylum. kingdom: The kingdom. organism_type: The type of organism. For plants, this is usually something like \"Herbaceous perennial\", or \"Shrub\". For animals, this could be, for example, \"mammal\" or \"reptile\". See here for more details (but also do not hesitate to contact me if there instances that fall outside of the classification given there). dicot_monocot: Whether the species is a dicotyledon or a monocotyledon (only applies to plants). angio_gymno: Whether the species is a angiosperm or a gymosperm (only applies to plants). 2.5.1.2 Publication information authors: The last names of each author on the manuscript, separated by a semicolon. journal: The abbreviated name of the journal that the model appears in. This follows the BIOSIS format. Exceptions are when the source is not a journal (e.g. a PhD/MSc thesis, government report). In that case, we use something like \"PhD Thesis\" and then include a link in the remark column. pub_year: The year the article was published. doi: The DOI of the publication (NOT THE doi.org URL though!!). corresponding_author: The last name of the corresponding author. email_year: The corresponding authors email, along with the year of publication in parentheses to denote how old (and possibly inaccessible) it is. For example, this could levisc8@gmail.com (2020). If you are able to find a more recent email address via Google, then this can also be used (this isnt necessarily expected though). remark: Any qualitative comments you may have on the model. These can range from comments to accuracy of GPS coordinates to descriptions of the different levels of a treatment that was applied. apa_citation: The full APA style citation for the paper. demog_appendix_link: If there is one, a link to the Electronic Supplementary Material that contains further details/parameter values for the model. 2.5.1.3 Data collection information duration: The duration of data collection used to implement the model. This is a crude measure, defined as end_year - start_year + 1, and does not account for years where data collection may have been skipped. start_year: The year that demographic data collection began. Formatted YYYY (e.g. 1990). start_month: The month of the year that demographic data collection began. This is an integer between 1 and 12, where 1 corresponds to January, and 12 corresponds to December. end_year: The final year of demographic data collection. Formatted YYYY. end_month: The month of the year that demographic data collection concluded. periodicity: Indicates the time step (periodicity) for which the seasonal, annual, or multi-annual IPM was constructed. For example, 1 indicates that the IPM iteration period is 1 year; 0.5 indicates that the IPM iterates once every 0.5 years or 6 months; 2 indicates that the IPM iteration occurs every 2 years. population_name: The name of the population given by the author. For example, \"Bear Creek\", or \"Havatselet\". If the population names are missing, use sequential names in alphabetical order (e.g. \"A\", \"B\", \"C\", etc). number_populations: Sometimes, a population_name may encompass multiple sub-populations that are located close by. This integer specifies the number of populations/sub-populations that are described by the model. lat: The decimal latitude of the population. Use the dms_deg function from pdbDigitUtils to generate this. lon: The decimal longitude of the population. Use the dms_deg function from pdbDigitUtils to generate this. altitude: The altitude above/below sea level, in meters. country: The ISO3 country code for the country in which the population is located. These are defined here. continent: The continent that the population is located on. Options are n_america, s_america, oceania, asia, europe and africa. Others may be added as needed. ecoregion: The ecoregion, as defined by the World Wildlife Fund (see here). 2.5.1.4 Model information studied_sex: The sex of the population studied. Options are M (male only), F (female only), H (hermaphrodites), M/F (males and females modeled separately, but in the same IPM), and A (all sexes studied together). eviction_used: Whether or not the authors account for unintentional eviction. This should either be TRUE or FALSE. Only put TRUE if an eviction correction is explicitly discussed, or you find model code in the supplementary materials and are able to discern the correct evict_type. evict_type: If an eviction correction was used, then the name of the method to correct it. Options are stretched_domain, rescale_kernel, truncated_distributions and discrete_extrema. rescale_kernel is the same as truncated_distributions and a relic of the past. Feel free to update those entries to truncated_distributions as you go. Notes on each are provided below. stretched_domain: This means that the authors extended the size boundaries some amount beyond the observed size distributions and relied on vital rate functions to prevent individuals from ever getting to the bounds. It doesnt apply any correction to the kernel, only extends the bounds of integration. It is possible that authors may use this in conjunction with another technique (e.g. stretched domain and a truncated distribution). When this happens, the other eviction correction should be entered, as those do apply a mathematical correction to the kernel. How to recognize: Authors usually state something to the effect of we multiplied the smallest observed value by 0.8 and the largest observed value by 1.2 to extend the range of integration truncated_distributions: This takes a distribution whose natural bounds extend beyond the desired integration bounds, and applies a correction that results in 0 density below the lower bound and above the upper bound. This is accomplished with \\(\\frac{g(x)}{F(b) - F(a)}\\) where \\(g(x)\\) is the un-truncated density function, and \\(F(a)\\) and \\(F(b)\\) denote the cumulative density function values for the lower and upper truncation bounds, respectively. How to recognize: Authors usually state we truncated the growth density function at the upper and lower bounds OR we used theconstant\" correction in IPMPack\" discrete_extrema: This takes the smallest and largest trait binds and effectively turns them into classes that correspond to smallest size in our model and also everything smaller. It does this by computing the amount of probability that is excluded at each value of \\(z&#39;\\) at the lower and upper bounds and adding that back in to the kernel at each extreme. How to recognize: Authors usually state we computed the amount of evicted individuals and added them back into the smallest and largest size bins OR we used thediscretizeExtremes\" correction in IPMpack\" treatment: A brief description of any experimental treatment that the authors applied to a given population. When there are multiple treatments with the same ipm_id, enter them separated by a semi-colon (;). Also see the note about how to enter this information in the HierarchTable. has_time_lag: Indicates whether any vital rates have a time lag (i.e. are a function of \\(n(z^*,t-1)\\) rather than \\(n(z, t)\\)). has_age: Indicates whether the model has age structure. has_dd: Indicates whether the model incorporates density dependence. is_periodic: Indicates whether or not the model is periodic. Periodic models arent currently supported by ipmr, and hence arent possible in PADRINO yet. 2.5.1.5 Database specific information 42 .embargo: Have the authors requested an embargo period for the model? .embargo_date: If so, when have they agreed to allow us to release it? Youve made it through the metadata table! Next, we will get into IPM specific details, starting with the state variables in use. 2.5.2 StateVariables ipm_id: The 6 digit alphanumeric ipm_id from the Metadata table. state_variable: the name of the of state variable that the model uses. This is largely up to you to choose. It can be descriptive (e.g. \"dbh\", \"leaf_area\"), or vague (\"size\"). discrete: Whether or not the state variable is discretely or continuously distributed. 2.5.3 ContinuousDomains ipm_id: The 6 digit alphanumeric ipm_id from the Metadata table. state_variable: the name of the continuous state variable. Should match the value from StateVariables table. domain: likely not useful and slated for deletion once I confirm this, skip for now. lower: the lower bound of the domain. upper: the upper bound of the domain. kernel_id: The name of the kernels that it appears in. Because of the way ipmr builds these models, you can actually omit the K values for new entries. They are present as a historical artefact, but will be removed eventually. The sub-kernel names should be separated by a semicolon (;). notes: any qualitative observations you have about the domain itself. 2.5.4 IntegrationRules ipm_id: The 6 digit alphanumeric ipm_id from the Metadata table. state_variable: the name of the continuous state variable. Should match the value from StateVariables table. domain: likely not useful and slated for deletion once I confirm this, skip for now. n_meshpoints: the number of meshpoints used for integration. The information this represents will vary depending on the integration rule. For now, the midpoint rule is the only one thats implemented in ipmr. This document will get updated to include formats for other integration rules as they are implemented in that package. integration_rule: the name of the integration rule. If a paper uses something besides \"midpoint\", write enter the name here, but do not worry about the n_meshpoints for now. kernel_id: the kernel name that the integration rule applies to. I cannot think of any cases where a model uses different integration rules for different sub-kernels, but I do not think it would be problematic either, and tree IPMs may go that direction as they become increasingly sophisticated. 2.5.5 StateVectors ipm_id: The 6 digit alphanumeric ipm_id from the Metadata table. expression: This is the name of the state_variable from the from the StateVariables table, with an \"n_\" appended to it to denote that it is a population state vector. n_bins: The number of bins it will be discretized into. For discrete states, this should always be 1. For continuous states, it should match the n_meshpoints value from the IntegrationRules table. comment: qualitative comments on the population state distribution function. 2.5.6 IpmKernels Because of the way that ipmr implements models, we only need to digitize sub-kernels to generate a complete IPM. In other words, there shouldnt be any need to enter expressions that create the \\(K(z&#39;,z)\\) iteration kernel, we only the need the \\(P(z&#39;,z)\\) and \\(F(z&#39;,z)\\). The rest of this guide is a sort of a quick-reference to remind you what goes where - for help writing kernel formulae, you should consult the Writing kernels, vital rate, and environmental stochasticity expressions guide. ipm_id: The 6 digit alphanumeric ipm_id from the Metadata table. kernel_id: The name of the IPM sub-kernel. formula: The formula describing how the vital rates combine to generate a sub-kernel. This field can make use of ipmrs suffix syntax, so kernels with identical functional forms do not need to be re-entered to work with different parameter values. model_family: One of 4 options: \"CC\": describes a continuous -&gt; continuous transition. \"DC\": describes a discrete -&gt; continuous transition. \"CD\": describes a continuous -&gt; discrete transition. \"DD\": describes a discrete -&gt; discrete transition. domain_start: the name of the state variable that the sub-kernel acts on. domain_end: the name of the state variable that the sub-kernel produces. 2.5.7 VitalRateExpr ipm_id: The 6 digit alphanumeric ipm_id from the Metadata table. demographic_parameter: The demographic process that the vital rate relates to. For example, could be Survival, Growth, Fecundity, or Clonal. formula: The mathematical formula for the vital rate. This field can make use of ipmrs suffix syntax, so vital rates with identical functional forms do not need to be re-entered to work with different parameter values. These can be split out into different cells if they are too long to safely write in a single cell. Vital rates that include probability distributions (e.g. growth, recruitment) must have their own line, and only take the parameters that the distribution accepts. For example: A growth kernel with a Gaussian distribution parameterized by a linear model must have two lines: \"mu_g = int_g + slope_g * z_1\" \"g = Norm(mu_g, sigma_g)\" The following will not work: \"g = Norm(int_g + slope_g * z_1, sigma_g)\" See Writing kernels, vital rate, and environmental stochasticity expressions guide for more details. See PADRINOs Probability Distribution Dictionary for each distributions notation. model_type: Should be either Evaluated or Substituted. Anything that contains a probability density function should be Substituted, and everything else will be Evaluated. kernel_id: The sub-kernel(s) that use the vital rate expression. If it appears in more than one kernel, you can put the sub-kernel names here separated by a semicolon (e.g. P; F). 2.5.8 ParameterValues ipm_id: The 6 digit alphanumeric ipm_id from the Metadata table. demographic_parameter: The demographic process that the parameter relates to. For example, could be Survival, Growth, Fecundity, or Clonal. Use General for a parameter that appears in multiple sub-kernels. state_variable: ignore for now. This column is probably going to get deleted. parameter_name: The name of the parameter. This should match the name that appears in VitalRateExpr$formula or IpmKernels$formula. The exception here is when using the suffix syntax. In this case, the actual value of the suffix must replace the suffix itself, and the parameter value should change from level to level. Consider the following example: In VitalRateExprformula, \"mu_g_yr = int_g_yr + slope_g * z_1\". The \"yr\" suffix can take on values 2008:2010. We would need to enter 3 values in the ParamterValues table: \"int_g_2008\", \"int_g_2009\", and \"int_g_2010\". parameter_value: The numeric value for the parameter. 2.5.9 EnvironmentalVariables ipm_id: The 6 digit alphanumeric ipm_id from the Metadata table. env_variable: Qualitative description of the environmental variable. vr_expr_name: The name of the variable as it appears in either the IpmKernels$formula, VitalRateExpr$formula, or EnvironmentalVariables$env_function. env_range: Three possibilities: A. Two numbers separated by a semicolon (;) denoting the minimum and maximum values that the environmental variable can take on. Use this when env_function is \"sample\". B. A single number corresponding to the value that the parameter can take. Use this when the env_function is NULL. C. NULL. Use this when env_function is something other than sample or NULL. env_function: Either the name of a function, or a mathematical expression to compute some value as a function of the parameters listed in this table or in ParameterValues. These will usually be either simple arithmetic (e.g. \"SE_rain * sqrt(n_env)\"), or a function that samples randomly from some distribution. This table also makes use of the Probability Distribution Dictionary, but substitutes rdist instead of ddist. There are couple additional functions that may appear: c: used to generate vectors of parameters. This is most commonly used to create a vector of means to pass to a multivariate normal distribution. sig_mat: used to generate a variance-covariance matrix to pass to a multivariate normal distribution. It takes a set of numbers and converts it to matrix in ROW MAJOR order (i.e. matrix(..., byrow = TRUE)). model_type: Should be either Evaluated, Parameter, or Substituted. Anything that contains a probability distribution should be Substituted. Anything that is not probability distribution or raw parameter value should be Evaluated (i.e. env_range is NULL and env_function is something other than a probability distribution). Anything that is a parameter value should be Parameter (i.e. env_range is a single number, and env_function is NULL). 2.5.10 ParSetIndices ipm_id: The 6 digit alphanumeric ipm_id from the Metadata table. env_variable: a qualitative explanation of the suffix. For experimental treatments that have been entered with the same ipm_id, enter \"Experimental Treatments\" here. vr_expr_name: the suffix that is used to abbreviate the env_variable in the IpmKernels formula/kernel_id, VitalRateExpr formula/kernel_id. range: An expression denoting the different levels that the each suffix can take on. For example, 2008:2011 to denote sampling years, or c(\"GNone\", \"GLow\", \"GMedium\", \"GHigh\") to denote grazing levels. kernel_id: the sub-kernel(s) that are modified by the suffix. drop_levels: This is used to denote which levels in a continuous sequence do not actually appear in the model. ipmr assumes the suffixes get fully crossed, and so we need to indicate that some levels are missing. For example, say a study sampled multiple sites (site = c(\"A\", \"B\", \"C\")) in multiple years (yr = 2010:2014). However, site A didnt get sampled in 2012 for some reason. We would add c(\"A_2012\") to the drop_levels column to make sure ipmr doesnt try to find parameters/sub-kernels for that level when rebuilding the model. 2.5.11 UncertaintyTable This table is not yet active, so skip for now. ipm_id: The 6 digit alphanumeric ipm_id from the Metadata table. 2.5.12 TestTargets This table is not user-facing, but we keep it to validate the models numerically. Basically, we want to make sure that the model, as weve entered it, can reproduce some target metric when re-constructed by ipmr. For now, the only supported target \\(\\lambda\\), because its quick and easy to compute, and its a single number (as opposed to, say, the right eigenvector or \\(\\lambda_s\\)). Stochastic \\(\\lambda\\) (\\(\\lambda_s\\)) is not supported because it can take quite some time to reproduce, and, because its the result of a stochastic process, may not be fully reproducible anyway. ipm_id: The 6 digit alphanumeric ipm_id from the Metadata table. target_name: \"lambda\" or \"lambda_suffixValue\" (if working with a grouped model). If you find that \\(\\lambda\\) values are hard to come by for some publications, but other values may work, let me know and we will figure out a syntax for supporting those. target_value: The numerical value of the target. precision: The number of digits that the target_value is reported to. Used to make sure floating point/rounding error doesnt cause us to exclude working models from database builds. 2.5.13 Summary Youve made it this far! Good work! There are a number of potential pitfalls one may encounter when digitizing. These are described below. 2.6 Common issues There are a number of issues that can (and probably will) arise when digitizing papers. Many authors do not include all the information needed to fully rebuild their models. Wrangling with \\(LaTeX\\) when creating pretty functional forms can introduce accidental typos which do not reflect the code that was used to actually build and analyze the model. Below, there are some guideline for how to handle these situations. 2.6.1 Missing information The vast majority of papers published do not contain all the information we need to re-build these IPMs. Therefore, we also contact authors to request the missing details. The most common ones are things like the numerical integration rule, the number of meshpoints, and the upper/lower bounds for the state variables used. Functional forms for some vital rates are also pretty common. We have a template for requesting information available in here (at some point, Ill convert that to a function that automatically generates email text given an ipm_id from a pdb_raw object. For now, youll need to edit it manually). 2.6.2 Exceptions to our digitization rules There are only a few times when we might want to enter a model differently from how it appears in the publication. The main way is when there is a typo in a functional form in the manuscript/appendix that doesnt match what is happening in the code the authors provide. For example, consider a survival model with a logistic regression of survival ~ size. The correct form would be: \\[ s_z = \\frac{1}{1 + exp(-(\\alpha_s + \\beta_s *z))} \\] However, the paper may contain the following form (notice the missing \\(-\\) in the denominator): \\[ s_z = \\frac{1}{1 + exp(\\alpha_s + \\beta_s *z)} \\] In this case, it is appropriate to contact the author to double check what the exact functional form used in the model is. If this turns out to be a typo, then we would update the functional form in the database to reflect the code used, rather than the text used in the manuscript. PADRINO is designed to be (pretty) language agnostic, and we would like to add ports to other languages (e.g. Julia, Python) after an initial stable release. However, for now, for now, there is an only R-based engine to use PADRINO. on the slack channel, papers that have been posted there and contain an IPM get a thumbs up reaction, all others get a thumbs down. You can reply in thread to open a discussion about whether or not to include a paper. This does not refer to model selection procedures with multiple candidate models, only the final models used in the IPM! "],["model-expressions-in-padrino.html", "3 Model expressions in PADRINO 3.1 Simple models 3.2 General models 3.3 Suffix syntax 3.4 Parameter resampled models 3.5 Age \\(\\times\\) size models 3.6 Answers to exercises", " 3 Model expressions in PADRINO PADRINO aims to store the mathematical forms of IPMs as text strings. This means that we need to be able to write out the IPM on paper/\\(LaTeX\\)/somewhere before we can really know how to enter it. It is important to have a basic understanding of how to write out functional forms for the mean response of a GLM. If you are not already familiar with these, please let speak to either Rob or Sam ASAP so we can get you up to speed! Models stored in PADRINO are rebuilt using ipmr. It will also be helpful to read that projects homepage, as well as the first two articles on simple and general IPMs. These readings will give you a much better understanding of how this package handles different vital rate expressions and kernel formulae. Since PADRINO depends on this package to rebuild models, the syntax it uses will look very similar to what should go into PADRINO (with a couple exceptions, namely when digitizing probability density functions). Finally, ipmr is designed to generate all model outputs via iteration, rather than generating large kernels and then using linear algebra methods to derive the relevant metrics. Therefore, we dont actually need to digitize the \\(K(z&#39;,z)\\) iteration kernel, only the sub-kernels that comprise the model (e.g. \\(P(z&#39;,z), F(z&#39;,z), C(z&#39;,z)\\)). However, the notation in many publications reports the iteration kernel, rather than the model iteration. Therefore, it will sometimes be necessary to re-write the published model in terms of the population state at time \\(t\\) and \\(t+1\\), rather than simply \\(K(z&#39;,z) = ...\\). There will be an example of this below as well. Well start with simple models, and build complexity as we go through. Note that for the sake of realism, were going to use examples where the notation used in the papers is not consistent with how wed write them in PADRINO (or perhaps even with how the rest of the foundational literature deals with these models). This will be prominent in the first three examples used here. 3.1 Simple models A simple IPM is an IPM that makes use of 1, and only 1, continuous state variable. It does not include any additional discrete states. These were more common in the early literature, though now more demanding analyses have required authors to create more complicated models. Models that use more than 1 continuous state, and/or include discrete states, are general models, and are detailed below. 3.1.1 An example model - Summary Below is a shortened description of a simple IPM for Lonicera maackii from Levin et al. 2019.4 \\(x,y\\) correspond to plant size at time \\(t\\) and \\(t+1\\), respectively. We will use size_1 and size_2 in place of \\(x,y\\) when writing out the model in PADRINO format (see below). \\(s(x)\\) (survival of plants) was estimated using a Bayesian logistic regression with both linear and quadratic fixed effects. \\(g(y,x)\\) (growth of surviving plants) was estimated using a linear regression of y ~ x. We also fit GAMs to our data to see if they produced better predictions. GAMs produced lower AIC scores, but visual inspection of the data for the competitor removal treatment showed that the GAM overfit the data. Thus, to ensure our control and competitor removal treatment IPMs were comparable, we modeled growth using the the linear model. We correct for eviction by adding evicted individuals into the smallest or largest bins after generating the growth kernel. \\(f_p(x)\\) (probability of becoming reproductive) was estimated using a logistic regression of reproductive status on size. We used a logit link and a quasi-binomial error structure to account for overdispersion in our data. \\(f_s(x)\\) (fruits per reproductive plant) was estimated using a generalized linear model with a log link and a Poisson error structure. \\(f_f\\) (seeds per fruit) is a constant based on sampling fruits from 12 individuals. \\(E_p\\) (seedling establishment probability) was taken from a separate experiment in our study that measured new recruits per estimated seed production per plot (Guthrie et al. 2016). \\(f_d(y)\\) (recruit size distribution) was estimated as a Gaussian distribution with mean \\(\\mu\\) and standard deviation \\(\\sigma\\) from the 17 new recruits that we found in July of 2013. \\(L,U\\) are constants corresponding to the lower and upper bounds of integration. \\(L\\) was defined as the smallest observed size \\(\\times\\) 0.9, and U was defined as the largest observed size \\(\\times\\) 1.1. We used 500 meshpoints for integration. \\(n(x,t)\\) is the relative frequency of individuals of size \\(x\\) at time \\(t\\). The kernels take the following form: \\(n(y, t+1) = \\int_L^U[P(y,x) + F(y,x)]n(x,t)dx\\) \\(P(y,x) = s(x) * g(y,x)\\) \\(F(y,x) = E_p * f_p(x) * f_s(x) * f_d(y)\\) The vital rates take the following form:5 \\(Logit(s(x)) = \\alpha_s + \\beta_{s,1} * x + \\beta_{s,2} * x^2\\) \\(\\alpha_s\\) = -2.831, \\(\\beta_{s,1}\\) = 0.4035, \\(\\beta_{s,2}\\) = -0.000421 \\(g(y,x) = \\alpha_g + \\beta_g * x\\) \\(\\alpha_g\\) = 16.884, \\(\\beta_g\\) = 0.9972, \\(sd(g(y,x)) = 32.74774\\) \\(Logit(f_p(x)) = \\alpha_{f_p} + \\beta_{f_p} * x\\) \\(\\alpha_{f_p}\\) = -10.4478, \\(\\beta_{f_p}\\) = 0.0485 \\(Log(f_s(x)) = \\alpha_{f_s} + \\beta_{f_s} * x\\) \\(\\alpha_{f_s}\\) = 3.391, \\(\\beta_{f_s}\\) = 0.0105 \\(f_d(y) = Norm(\\mu_{f_d} = 3.118, \\sigma_{f_d} = 1.215)\\) 3.1.2 How to digitize this? Now that weve written out the model based on the Appendixs description of how it works, we need to convert this to something PADRINO and ipmr can work with. Ive found that its usually easiest to start with the sub-kernels and work top-down, though you are free to start with parameters and work bottom-up. Its up to you! 3.1.3 Sub-kernels Well start with the IPM kernels. PADRINO basically uses the mathematical notation from above, but removes the \\((x,y)\\) portion. So the \\(P(x,y) = s(x) * g(y,x)\\) becomes P = s * g. Similarly, \\(F(y,x) = ...\\) becomes F = e_p * f_p * f_s * f_d. We do not need to write out the model iteration from Equation 1. ipmr infers the correct form of that, provided we use the right states in domain_start and domain_end columns for each kernel formula. Another important thing to note is that is that it really doesnt matter what you call the kernels, vital rates, and parameters. What matters is that their names match across the various tables in the database. Thus, if an author gives some vital rate a ludicrously long name, feel free to shorten it.6 The examples below use the same names as the notation above for kernels, vital rates, and parameters, but this is not required! Finally, because of some design decisions early in the development process, you must always separate the left and right hand side of an = with a space. For example, the P = s * g from above will not work if it is entered as P=s*g. On the bright side, it will make the formulae that you enter easier to read!7 3.1.4 Vital rate expressions PADRINO uses a similar notation as above, except now there are two new elements: We will move all the link functions on the left hand side of each equation to the right hand side, and use the inverse link function instead. Table 1 below contains translations of some common link functions and their inverses.8 We only remove the \\(x,y\\) from the left hand side of the equation. 3.1.5 Survival The survival function \\(Logit(s(x)) = \\alpha_s + \\beta_{s,1} * x + \\beta_{s,2} * x^2\\) becomes: s = 1 / (1 + exp(-(alpha_s + beta_s_1 * size_1 + beta_s_2 * size_1 ^ 2))) The 1 / (1 + exp(- (...))) is the inverse logit transformation. This generates probabilities of survival, which is what we want for the IPM. Additionally, notice how the \\(x\\)s were replaced by size_1s on the right hand side of the equation. Next, well deal with the growth kernel. NB: Many more recent papers will have more complicated forms for the linear predictor which include terms for things like climate or competition. If the linear predictor gets really long, we can actually split it out into its own line in PADRINO like so: -s_lin_p = alpha_s + beta_s_1 * size_1 + beta_s_2 * size_1 ^ 2 -s = 1 / (1 + exp(- s_lin_p)) 3.1.6 Growth In this case, the growth kernel uses a notation that will not work with PADRINO. However, the written description of the model indicates this is a linear regression with a Gaussian error structure. We can re-write this model using a more conventional notation. We can do this like so: \\(g(y,x) = f_g(y, \\mu_g, \\sigma_g)\\) Where \\(f_g\\) denotes a Gaussian probability density function. \\(\\mu_g = \\alpha_g + \\beta_g * x\\) This format will correspond more closely to how we enter it PADRINO. Note that PADRINO does not use the R functions like dnorm, dgamma, etc. Rather, it uses its own shorthand that roughly follows the accepted statistical abbreviations for each probability function family (with some exceptions to avoid name conflicts in R/other languages). A table that contains the PADRINO format is here. PADRINO uses the Abbreviation column of this table. The PADRINO format for (1) and (2) become: g = Norm(mu_g, sigma_g) mu_g = alpha_g + beta_g * size_1 Notice that we omit the \\(y\\) from the right hand side of (1). PADRINO will infer the correct state variable based on the kernel it appears in (however, see the next section for an exception to this rule!). Additionally, in this particular case, their is no link function (or, rather, its an identity link function which we can ignore), so we dont need to wrap the right hand side of (2) in any thing. 3.1.6.1 first_arg and when to use it Directly above, we said that we do not write \\(y\\) in the call to Norm(...). This is almost always true. However, there is an exception to this. Say that the computed value is the probablity density of a difference in values. This happens in some models that include mating preferences. In this case, wed need to specify Norm(z_2 - z_1, mu, sigma). However, that wont work either, because RPadrino will still assume it needs to insert the state variable. We can switch off that behavior (i.e. automatically inserting state variables) by adding an additional argument to Norm(...): first_arg. This is a logical and its assumed to be FALSE all the time, so you only need to add it when you need this. In that case, we would write Norm(z_2 - z_1, mu, sigma, first_arg = TRUE). This will prevent RPadrino from doing any kind of state variable substitution, and simply evaluate the rest of the statement. Note that it doesnt switch off the parameter set index notation, so you can still use that when first_arg = TRUE! 3.1.7 Seed production The next vital rate well go to is seed production: \\(Log(f_s(x)) = \\alpha_{f_s} + \\beta_{f_s} * x\\). Much like the survival model, well need to use an inverse link function on the right hand side. Unlike the survival model, we dont need the inverse logit, but rather, the exponential function (the inverse of the \\(Log\\)). f_s = exp(alpha_f_s + beta_f_s * size_1) 3.1.8 Probability of flowering and recruit size distributions. These are similar to survival probability and the growth distributions. In the spirit of learning, try writing these down on your own and then checking them against the answers given down here. 3.2 General models Above, we dealt with a simple model. It was a simple model because it used only 1 state variable, and had no discrete states. The vast majority of newly published IPMs are not simple models. Complex lifecycles often cannot be described by a single trait value. General IPMs allow for multiple continuous traits, and/or multiple discrete states. In PADRINO, little changes with respect to vital rate expressions and parameter values. However, the IPM kernels table will have more entries per model now, as we need more sub-kernels to describe the extra transitions. Examples of discrete states are things like a seed bank for a plant, or the number of eggs produced by an insect that do not hatch immediately. These are discrete because they do not have any continuous trait that describes their population dynamics, only a single number indicating how many of them there are. Some IPMs may have multiple continuous state variables. For example, a tree species may use height to describe dynamics of a seedlings below a certain size threshold, and then DBH (diameter at breast height) to describe the dynamics of larger trees. Below, well go through another example from Baer &amp; Maron (2018). Well look at a single transition year from a single population first, and then use the rest of the data in the next example to demonstrate the suffix syntax that PADRINO uses. You can find the main text here and the appendix containing the necessary information here. 3.2.1 Where to begin Assuming weve already entered most of the Metadata table, the first step is figuring out where to get the rest of it. Browsing through the paper, it looks like section 2.4 is likely to contain the information on the actual IPM. The end of the first paragraph contains key information on the number of kernels: Our IPMs contained a continuous stage describing size based vital rates of juvenile and reproductive adult plants and two discrete stages in which constants described the vital rates of seedlings (whose size was not recorded) and seeds within the seed bank. The continuous stage of our IPMs was structured according to logtransformed basal rosette area (hereafter, size) and integrated across a range of sizes from the minimum size to 1.2 times the maximum size of any individual recorded in a population throughout all years of the study. Ok, so we have 3 different states that well need to track: size of non-seedling plants, the number of seedlings, and the number of seeds in the seedbank. Next, we need to find out how they move around within and between those states. It becomes apparent from reading on that we wont find that information in the main text. However, the first sentence in the second column on page 5 indicates that we might be able to find it in Appendix S1. Lets open that up! 3.2.2 Digitizing the kernel formulae Lets start with the seed bank terms. Theyve written it out as: \\[ B_{t+1} = B_t * p_{sbanksurv} * (1-p_{sbankgerm}) + \\int_L^Up_{flower}(x)*f_{seeds}(x) * (1-p_{germ})n_t(x)dx \\] This expression is comprised of two sub-kernels, which we can recognize by the + that occurs about halfway through, and the fact that one part is multiplied by a discrete state (\\(B_t\\)) and another part is multiplied by a continuous state (\\(n_t(x)\\)). Thus, we need to split this single expression into two lines in the IpmKernels table. Bearing in mind that we do not include the actual state in these expressions (i.e. \\(B_t\\) and \\(n_t(x)\\)), these will take the form (column names now separated by commas): formula = SbStay = sb_surv * (1 - sb_germ), model_family = DD, domain_start = seedbank, domain_end = seedbank SbGo = p_fl * n_seeds * (1 - p_germ) * d_size, model_family = CD, domain_start = size, domain_end = seedbank One critical aspect to note is that in this case, weve added the d_size variable to expression 2. ipmr requires us to specify the integration for general IPMs, whereas it will automatically infer it for simple ones. In all cases, if you encounter an integral, this d_size will correspond to the \\(dx\\) in the integral. We just need to make sure we choose the state variable correctly. Additionally, we now have different values for model_family, domain_start, and domain_end. We can now move onto the second expression in the IPM iteration: \\[ S_{t+1} = p_{sbankgerm} * B_t + \\int_L^U p_{flower}(x) * f_{seeds}(x) * p_{germ} n_t(x)dx \\] Again, we have two sub-kernels defined in this portion of the iteration. The first moves seeds out of the seedbank to create seedlings, and the other creates seedlings from adult plants that are reproductive. We write them as follows: formula = SbSdl = p_sb_germ, model_family = DD, domain_start = seedbank, domain_end = seedling formula = goSdl = p_fl * n_seeds * p_germ * d_size, model_family = CD, domain_start = size, domain_end = seedling The final part of the IPM iteration generates plants with some size distribution. It has the following form: \\[ K = p_{seedlingsurv} * f_{recrsize}(x&#39;) * S_t + \\int_L^Us(x) * g(x&#39;|x)n_t(x)dx \\] Try writing out the formula, model_family, domain_start, and domain_end on your own. You can check your answers here. This one will be tricky because the notation in this particular equation tells you what the iteration kernel \\(K\\) looks like for the continuously distributed variable, size. We need to re-write it so the left hand side is the continuous portion of the population state at \\(t+1\\) (i.e. \\(n(x&#39;,t+1) = ...\\))?. Hint: the function for new recruit sizes (\\(f_{recrsize}(x&#39;)\\)) is a probability density function. 3.2.3 Digitizing the Vital rate expressions Most of the vital rate expressions are only described qualitatively, rather than explicitly written out. Additionally, they are mostly written out in the main text, specifically in the second and third paragraphs of section 2.4. Well start by parsing the following section: Within the continuous portion of the IPMs, logistic regressions with a logit link described sizebased binomial survival probability. Linear models described sizebased growth rates and variance around this relationship. Logtransformation of plant size eliminated the need for a sizebased estimate of the variance around the size growth relationship for most models, as verified by a BreuschPagan test performed on each model for this relationship (bptest, lmtest package, Zeileis &amp; Hothorn, 2002). In these cases, variance was described according to the residual standard deviation. For sizegrowth models that remained heteroscedastic following logtransformation of plant size, we described variance in growth as an exponential function of logtransformed plant size when constructing growth models: \\(\\sigma(size) = \\sqrt{\\sigma^{2[2 * constant * size]}}\\), where the constant and \\(\\sigma^2\\) were calculated within IPMpack We compared the fit of models containing linear and quadratic terms for each vital rate using their corrected Aikake Index Criterion scores (AICc; quasiAICcQAICcfor models of overdispersed per capita seed production). If \\(\\Delta(Q)AICc &gt; 2\\), we selected the model with the lower score unless the model was graphically determined to be biologically unrealistic (Supporting Information Appendix S1). In cases where \\(\\Delta(Q)AICc \\leq 2\\), we constructed models with averaged parameters weighted by (Q)AICc score (model.avg(); MuMIn package; Barton, 2016). 3.2.4 Survival It helps to split out the different vital rates when working out the correct functional form. Well start with survival, which well denote \\(s(x)\\) to follow their notation in the IPM kernels. They first specify that they used logistic regression with a logit link, so we know that the left hand side of the vital rate will look like this: \\(Logit(s(x)) = ...\\) Next, we need to work out what the linear predictor looks like. In the latter half of the quoted section above, the authors state that they compared models that included linear and quadratic fits, and then possibly averaged over the predictions if the two candidate models were not sufficiently different in their predictive ability. However, it will be more general of an approach to always included the quadratic term in the vital rate expression, and then set the coefficient to 0 if it turns out that the model selection procedure chose the linear model over the quadratic/averaged model. Thus, we write: \\(Logit(s(x)) = \\alpha_s + \\beta_{s,1} * x + \\beta_{s,2} * x^2\\) with the understanding that \\(\\beta_{s,2}\\) can be 0, which yields the linear model. Well get into why this is helpful in the Suffix syntax section below. Now that we have our nice functional form for the regression model, we can re-write it with PADRINOs syntax (remember to use the inverse link function!): s = 1/ (1 + exp( - (s_int + s_slope_1 * size_1 + s_slope_2 * size_1 ^ 2))) 3.2.5 Growth The growth model is similar to the survival model in terms of how the mean is parameterized, but the variance is something new for us. Fear not! We can actually accommodate this form with just one extra row in the VitalRateExpr table. Again, the first step is to write out whats going on. We have our linear and quadratic models that compute the mean size at \\(t+1\\) given the size at \\(t\\). Furthermore, it sounds like this is a linear regression with a Gaussian error distribution. However, they also mention that the variance in growth may be a function of size as well. Fortunately, they also provide the equation that tells us exactly how to compute that quantity (rather, they provide even more conveniently, the formula for the standard deviation, which is what we need for the growth kernel anyway). So, lets write down whats going on, first using the trick we used above for the linear/quadratic functional form. \\(\\mu_g = \\alpha_g + \\beta_{g,1} * x + \\beta_{g,2} * x^2\\) Next, we also need to write out how to compute the standard deviation. The authors note that sometimes, they assume a constant variance around the growth curve, while other times, there is an exponential change in it as a function of initial size. Well write it so that its always an exponential function, and then see how to alter the way we enter the data so that we can use that functional form, no matter which type of model was actually used: \\(\\sigma(x) = \\sqrt{\\sigma^2 * e^{2 * \\beta_{gv} * x]}}\\) Ok, so what does this mean for us? For the exponential function case, we just need to find the value for the models variance \\(\\sigma^2\\) and \\(\\beta_{gv}\\), the parameter that controls how rapidly the standard deviation changes with size. These are reported in the Appendix of this paper. For the model that uses constant variance, these authors report the standard deviation, rather than the variance. Thus, when we enter the parameter values for the constant variance models, we should enter the squared value of the standard deviation as the models variance, and then set \\(\\beta_{gv}\\) to 0, as anything raised to the zero-th power is 1 (i.e. it will become \\(\\sqrt{\\sigma^2 * 1}\\)). In PADRINO syntax, the complete set of expressions are: - `g = Norm(mu_g, sigma_g)` - `mu_g = g_int + g_slope_1 * size_1 + g_slope_2 * size_1^2` - `sigma_g = sqrt(sigma_2_g * exp(2 * g_var_slope * size_1))` 3.2.6 Seed production The final bit of new syntax well introduce here is for the seed production part of the model. The authors state that they used a GLM with a quasi-Poisson error and a log link. We are only interested in the link function for now.9 The authors state that they compared linear and quadratic forms, so well use the same trick as before to enter a general formula for the vital rate expression and adjust the parameter values to work with it. Furthermore, they state that seed production was capped at the maximum observed seed number for each year \\(\\times\\) site combination. This indicates well need a second expression to implement to the capping. Fortunately, they tell us the caps value at each year \\(\\times\\) site combination in the appendix, so we can add that as a parameter. First, we need to write out whats going on. The model can generally be summarized as: \\(Log(f_{s}(x)) = \\alpha_{f_s} + \\beta_{f_s,1} * x + \\beta_{f_s,2} * x^2\\) \\(f_{seeds}(x) = \\begin{cases} f_s(x) &amp; \\text{if } f_s(x) &lt; f_{max} \\\\ f_{max} &amp; \\text{if } f_s(x) \\geq f_{max} \\end{cases}\\) The first equation should look familiar based on the first example we did. The second one is a piece-wise function with a condition that sets out when to use the estimated fecundity and when to use the maximum value. PADRINO does its best to remain language-agnostic, that is provide a syntax that is not specific to R, even if thats what were working with. However, for the second expression, weve decided to use Rs ifelse() in PADRINO.10 These expressions then become: f_s = exp(f_s_int + f_s_b_1 * size_1 + f_s_b_2 * size_1 ^2 n_seeds = ifelse(f_s &lt; seed_max, f_s, seed_max) Rather than attempt to write out the rest of the expressions, well now move on to the suffix syntax that ipmr and PADRINO use. Well now work on a single site from Baer 2018, but well start writing expressions that represent all years sampled. 3.3 Suffix syntax ipmr implements a suffix syntax thats meant to mirror the sub-/super-script notation of the math that represents IPMs. This allows us to create expressions that are indexed by some variable, usually time or space (e.g. sites, population, etc.), and can save a considerable amount of duplication in the database. Well go through a quick introduction here, and then the worked example. If you want to read more about it, there is a vignette with a lengthier here. Well use the same paper as the general IPM example above, except this time, were going to modfiy the time-varying expressions by appending a suffix to each parameter/vital rate/kernel. Since the interval of time-varying is year to year, well use the subscript \\(x_{yr}\\) in the mathematical formulae, and the suffix _yr in PADRINO. 3.3.1 Re-writing the model iteration As before, we want to write out the expressions first. The catch here is that we need to take note of which parameters are time-varying and modify those symbols accordingly. Glancing at the parameter tables in Appendix 1, we note that for each site, the only time-invariant parameters are \\(p_{sbanksurv}, p_{germ}, p_{sbankgerm}\\). Therefore, well add a subscript (\\(x_{yr}\\)) for each year to every other vital rate function and parameter. Beginning with the iteration for the seedbank, we get: \\[ B_{t+1} = B_t * p_{sbanksurv} * (1-p_{sbankgerm}) + \\int_L^Up_{flower,yr}(x)*f_{seeds,yr}(x) * (1-p_{germ})n_t(x)dx \\] Next, we modify the iteration for the seedling stage: \\[ S_{t+1} = p_{sbankgerm} * B_t + \\int_L^U p_{flower,yr}(x) * f_{seeds,yr}(x) * p_{germ} n_t(x)dx \\] And finally, we update the continuous distribution of plant sizes: 11 \\[ n_{t+1}(x&#39;) = p_{seedlingsurv,yr} * S_t * \\int_L^U f_{recrsize,yr}(x&#39;)dx + \\int_L^Us_{yr}(x) * g_{yr}(x&#39;|x)n_t(x)dx \\] Now that weve modified the model iteration, we can enter these into the IpmKernels table. For the seedling class (\\(S_{t+1}\\)), will have the following form: formula = SbSdl = p_sb_germ, model_family = DD, domain_start = seedbank, domain_end = seedling formula = goSdl = p_fl_yr * n_seeds_yr * p_germ * d_size, model_family = CD, domain_start = size, domain_end = seedling Try writing out the formulae, model_family, and domain_start/end for the other two states in the model. You can check your answers here. 3.3.2 Time-varying vital rate expressions In order to express the time varying functions, we also need to add subscripts/suffixes to each of the symbols in the vital rate expressions. In the case of this model, we can see that, relative to the General IPM exercise, we need to add suffixes to the following vital rates: \\(p_{flower,yr}\\) \\(f_{seeds,yr}\\) \\(p_{seedlingsurv,yr}\\) \\(f_{recrsize,yr}\\) \\(s_{yr}\\) \\(g_{yr}\\) 3.3.3 Survival Starting with survival at the Bountiful population, we see that 2 of the years have quadratic terms, and the first year does not. We can still write all of these using the quadratic functional form, and then just set s_slope_2_2013 to 0 in the ParameterValues table. On paper, we can express the model like this: \\(Logit(s_{yr}(x)) = \\alpha_{s,yr} + \\beta_{s,1,yr} * x + \\beta_{s,2,yr} * x^2\\) In PADRINO, we append the suffix _yr to each parameter value it modifies: s_yr = s_int_yr + s_slope_1_yr * size_1 + s_slope_2_yr * size_1^2 In the ParameterValues table, well need to enter 9 rows for this vital rate: Intercepts: s_int_2013, s_int_2014, s_int_2015 First slope: s_slope_1_2013, s_slope_1_2014, s_slope_1_2015 Second slope: s_slope_2_2013, s_slope_2_2014, s_slope_2_2015 Next, in the HierarchTable, we need to enter the following: vr_expr_name = yr, range = 2013:2015 3.3.4 Growth Next, well do growth. Like survival, growth at Bountiful will have the same functional form as the General IPM example, except now with subscripts/suffixes. We write it out as follows: \\(g_{yr}(x&#39;, x) = f_g(x&#39;, \\mu_{g,yr}, \\sigma_{g,yr})\\) where \\(f_g\\) is a Normal probability density function. \\(\\mu_{g,yr} = \\alpha_{g,yr} + \\beta_{g,1,yr} * x + \\beta_{g,2,yr} * x^2\\) \\(\\sigma_{g,yr} = \\sqrt{\\sigma^2_{g,yr} * e ^ {2 * \\beta_{gv, yr} * x}}\\) We can write out the PADRINO expressions like so: g_yr = Norm(mu_g_yr, sigma_g_yr) mu_g_yr = g_int_yr + g_slope_1_yr * size_1 + g_slope_2_yr * size_1 ^ 2 sigma_g_yr = sqrt(sigma_2_g_yr * exp(2 * beta_gv_yr * size_1)) The next step will be to enter the parameter values in the ParameterValues table. We dont need to enter anything more in the HierarchTable - those values can be used by the whole IPM. 3.3.5 The rest of the vital rates Try writing these out on your own, and checking the answers here 3.4 Parameter resampled models Parameter re-sampled models refer to stochastic models where some parameters are treated as time-varying random variables. The EnvironmentalVariables table is meant to hold the parameters associated with these random variables (e.g. the mean and variance of a temperature distribution), and the random number generators that produce values (e.g. the Norm(temp_mu, temp_sd)). These distribution functions use the same notation as the density functions, so you can still use the Probability Function Dictionary to translate these into PADRINO notation. The way that we enter vital rate expressions and IPM sub-kernels doesnt change when working with these models. The only additional bit is that we now enter some of the parameters and expressions into the EnvironmentalVariables table. I will find a suitable example for this in the not so distant future. 3.4.1 Model iterations Coming soon! 3.4.2 Vital rate expressions Coming soon! 3.4.3 EnvironmentalVariables expressions Coming soon! 3.5 Age \\(\\times\\) size models Coming soon! 3.6 Answers to exercises 3.6.1 Simple model Pr(flowering) and recruit size \\(Logit(f_p(x)) = \\alpha_{f_p} + \\beta_{f_p} * x\\) f_p = 1 / (1 + exp(-(alpha_f_p + beta_f_p * size_1))) \\(f_d(y) = Norm(\\mu_{f_d}, \\sigma_{f_d})\\) f_d = Norm(mu_f_d, sigma_f_d) Resume from General models 3.6.2 General IPM kernel formulae \\(K = p_{seedlingsurv} * f_{recrsize}(x&#39;) * S_t + \\int_L^Us(x) * g(x&#39;|x)n_t(x)dx\\) formula = SdlOut = p_sdl_surv * sdl_size * d_size, model_family = DC, domain_start = seedling, domain_end = size formula = P = s * g * d_size, model_family = CC, domain_start = size, domain_end = size \\(K\\) re-write: \\(n(x&#39;,t+1) = p_{seedlingsurv} * S_t * \\int_L^Uf_{recrsize}(x&#39;)dx + \\int_L^Us(x) * g(x&#39;|x)n_t(x)dx\\) Back to vital rate expressions in General IPMs 3.6.3 Suffix syntax kernel formulae 3.6.3.1 Seed bank formula = SbStay = sb_surv * (1 - sb_germ), model_family = DD, domain_start = seedbank, domain_end = seedbank SbGo_yr = p_fl_yr * n_seeds_yr * (1 - p_germ) * d_size, model_family = CD, domain_start = size, domain_end = seedbank 3.6.3.2 Plants formula = SdlOut_yr = p_sdl_surv * sdl_size_yr * d_size, model_family = DC, domain_start = seedling, domain_end = size formula = P_yr = s_yr * g_yr * d_size, model_family = CC, domain_start = size, domain_end = size 3.6.3.3 Vital Rates \\(Logit(p_{flower,yr}(x)) = \\alpha_{p_f,yr} + \\beta_{1,p_f,yr} * x + \\beta_{2,p_f,yr} * x^2\\) p_fl_yr = 1 / (1 + exp(-(p_fl_int_yr + p_fl_slope_1_yr * size_1 + p_fl_slope_2_yr * size_2 ^ 2))) ParameterValues entries: p_fl_int_2013, p_fl_int_2014, p_fl_int_2015 p_fl_slope_1_2013, p_fl_slope_1_2014, p_fl_slope_1_2015 p_fl_slope_2_2013, p_fl_slope_2_2014, p_fl_slope_2_2015 There are two expressions here. One for the predicted mean, and the other for the conditional cap on seed production \\(f_{s,yr} = \\alpha_{f_s,yr} + \\beta_{f_s,1, yr} * x + \\beta_{f_s, 2, yr} * x ^ 2\\) \\(f_{seeds,yr}(x) = \\begin{cases} f_{s,yr}(x) &amp; \\text{if } f_{s,yr}(x) &lt; f_{max,yr} \\\\ f_{max,yr} &amp; \\text{if } f_{s,yr}(x) \\geq f_{max,yr} \\end{cases}\\) f_s_yr = exp(f_s_int_yr + f_s_slope_1_yr * size_1 + f_s_slope_2_yr * size_1 ^ 2) f_seeds_yr = ifelse(f_s_yr &lt; seed_max_yr, f_s_yr, seed_max_yr) ParameterValues entries: f_s_int_2013, f_s_int_2014, f_s_int_2015 f_s_slope_1_2013, f_s_slope_1_2014, f_s_slope_1_2015 f_s_slope_2_2013, f_s_slope_2_2014, f_s_slope_2_2015 seed_max_2013, seed_max_2014, seed_max_2015 \\(p_{seedlingsurv,yr}\\): This actually has no expression, its just a set of 3 parameter values. sdl_s_2013, sdl_s_2014, sdl_s_2015 \\(f_{recrsize, yr} = Norm(\\mu_{recrsize,yr}, \\sigma_{recrsize, yr})\\) ParameterValues entries: mu_rcsz_2013, mu_rcsz_2014, mu_rcsz_2015 sigma_rcsz_2013, sigma_rcsz_2014, sigma_rcsz_2015 Back to Suffix Notation We will only look at the control treatment for now The notation used here is from the paper. We will need to re-write some of these to work in PADRINO. Caveat: in the course of debugging, it may be harder to track very short names. Additionally, if you have to wait a while for an author response to a question, you may forget what everything stand for by the time you return to a model! I hope to update this to take names from a separate column at some point, rather than using the left hand side of the =. However, since it currently works and only requires a bit of care when digitizing, this change isnt particularly high on my priority list. Table 15.1 on the second page of this book The error family is important in the estimation step, and when quantifying uncertainty in the model. However, implementing a model with observed parameter values is unaffected by this, so well ignore quasi-Poisson part for now, and return to it when we need to deal with the UncertaintyTable. This should be translatable to, for example, C++s ternary operator equivalent x &gt; y ? a : b. NB: This has been re-written from the notation used in the appendix so that it is a model iteration rather than an iteration kernel. This is suffix-notation version of the exercise in the General IPMs section. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
